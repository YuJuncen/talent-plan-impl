# PingCAP Talent Plan implemention

这是我在 `TiKV` 方向的一个实现。  

我曾经用 `actix` 和 `tokio` 半娱乐地做过一个小型的 `Rust`项目：我的博客后端，因此对 `Rust` 还算有些基础；我很喜欢这门有些奇特的语言——它有着非常深厚的命令式血脉、精致的内存管理、许多前沿的语言特性、用 `Prelude` 做常用模块的名字（`Haskell` 那一类语言经常这样干）……  

## Note

### project 1

工作非常简单——仅仅是温习了一下 `rust` 的模块机制还有相关的工具链。顺便感慨一下 `async/await` 终于快要提上日程（我上一个项目的异步编程完全就是灾难！）。  

### project 2

一些新的问题开始呈现。  

最显著的问题是文件 IO 相关的多重难题：我开始疑惑为何 `Read` 会需要可变的借用：这样 `get` 方法也必须获得自身的可变引用，这在多线程的环境下可以说是灾难性的——因为只能有一个线程获得可变引用。  

我尝试使用内部可变性还有分离读写的句柄来解决这个问题；然后很快发现事情比想象的更加复杂：而且因为可变借用的唯一性，连仅有的 race condition 都不存在了，索性放飞自我了——在压缩的时候，按照索引创建新的文件，然后直接 `fs::copy` 了事，反正没有人可以在我们写文件的时候读。  

### project 3

后来，我逐渐发现 `rust` 的安全性比我想象的要高许多——数据结构即便在线程之间被共享，也会需要遵循最基本的借用规则；同时通过借用来在线程之间共享数据比想象的会艰难不少——因为线程的生存时间并不确定，所以我们几乎无法向 `rustc` 证明我们的借用是安全的（即便在它消失之前调用 `join` 也不行，`rustc` 就是这样，不是 `'static` 的都不可以！）。

于是实现 `Clone` 成为了在线程之间共享数据的最好方法——熟悉 `Java` 的人可能很快就会开始嘲讽我们“重新发明了 `ThreadLocal`”——看起来性质差不多，但是还是有些许不同，至少我们可以用 `Arc` 来实现类似 `Java` 中的变量共享风格。

使用 `Arc` 之后还有更加棘手的事情：`Arc` 仅仅实现了 `Deref`，它无法改变被共享的值——最终，我们还是要面对内部可变性（哎！）。  

接下来呢？即便使用内部可变性和 `Arc` 共享句柄，我们仍旧没有办法同时读多个文件——可变借用说到底还是只能有一个。这个问题的解决方案相当平凡——不再使用 `Arc` 或者内部可变性来共享文件，而是实现 `Clone`，为每一个线程中的实例重新打开一次文件，剩下的交给操作系统还有硬件去调度吧（说不定还可以利用 SSD 的并行机制）。

另一件非常有趣的事情是，在单线程的 benchmark 中，我们乱拳打死老师傅了：

```
kvs                     time:   [1.4274 s 1.4436 s 1.4634 s]                 
                        change: [-3.0782% -0.1901% +2.6514%] (p = 0.91 > 0.05)
                        No change in performance detected.

sled                    time:   [1.5484 s 1.5963 s 1.6223 s]  
```

原因（我猜的）大概是因为 `sled` 使用了某种 `LSM Tree` 作为索引（因为它要支持高效的区间查询），所以具有更大的写放大，同时若读取的键不在 L0 缓存中，或者根本不存在，则会拥有很大的读放大；而我们使用的哈希索引，在内存中足以存放索引、又不需要支持区间查询的前提下，能够拥有还算不错的性能；同时由于测试是单线程的，所以我们的实现那灾难般的并发劣势也没有显现出来。

还有值得一提的是，我们在服务器端使用了 `Tokio` 实现——这事实上并没有什么意义，因为硬盘的 IO 会阻塞掉协程；所以事实上，我们的工作性质接近于单纯地重用了 `Tokio` 中实现的线程池。

接下来我们还要做更多——暂时让把 `Tokio` 放一放，来实现我们的线程池吧。

## project 4

我们现在需要用到两件重要的工具：

- `Arc`，用来在线程之间共享内存。
- `RwLock`、`Mutex`、`RefCell`，用来实现内部可变性。

我们遇到的第一个问题是 `Clone` 和 Trait Object 的阻抗失配，因为 Trait Object 使用和 `C++` 虚表不同的胖指针——如果某个 Trait 要求 `Self: Sized`，则我们无法将其封装为 Trait Object。

这个问题可以使用一定程度上的内联代码解决，或许写一个宏是更加好的解决方案，但是如今看起来，似乎也没啥必要。

线程池的实现遇到的问题相对来讲不多；仅仅是“有些麻烦”——我们需要在 `Rust` 中模拟 `Erlang` 那般的消息传递机制（`Worker` 和 `Master` 的表现相当接近 `Erlang` 中的线程——接受消息，而后同步或者异步地返回），但是我们却仅有如同 `Go` 语言般的信道，二者虽然颇为相似，但是确实有些微妙的差别——因为并非每一个发送者都有一个 `Pid`，要模拟同步调用的话需要一些额外的抽象，大概长这样：

```rust
fn spawn<R>(&mut self, runnable: R) where
	R: Send + 'static + FnOnce() {
  // Here, we are creating the channel explicitly.
	let (s, r) = unbounded();
	self.pool.send(RunTask(Box::new(runable), 
    // here, is the `sender` for synchronous call
    s));
  if let Err(_) = r.recv() {
    panic!("Failed to start thread...");
  }
}
```

而在 `Erlang` 一类的 `Actor System` 中，创建信道的过程可以被省略，而后我们的代码可能长这样。

```erlang
poolSwpan(Pool, Task) ->
	Pool ! [newtask, Task, self()],
  receive 
    ok -> ok;
    [err, Message] -> [err, Message]
 	end.
```

不过就最终的接口来看，我们还是会将一切协议都封装起来的，所以反倒不是什么大事，仅仅是麻烦罢了。